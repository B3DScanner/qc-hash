//==============================================================================
// Set /////////////////////////////////////////////////////////////////////////
//==============================================================================
// Austin Quick, 2016 - 2018
//------------------------------------------------------------------------------
// Unordered node-based hash set implementation with an emphasis on performance.
// https://github.com/Daskie/QHash
//------------------------------------------------------------------------------



#pragma once



#include <memory>

#include "Hash.hpp"



namespace qc {



namespace config {

namespace set {

constexpr size_t defNSlots(16); // number of slots when unspecified

}

}



//======================================================================================================================
// Set /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//======================================================================================================================
// Setup as a array of slots (buckets), each having a linked list (not
// std::list) of nodes, each containing a hash, a pointer to the next node, and
// an element value.
// Will always have a minimum of 1 slot, but may have 0 size.
// Memory for the number of slot's worth of nodes is pre-allocated. This is a
// huge performance boost with the cost of extra memory usage for un-full sets.
//------------------------------------------------------------------------------

template <typename K, typename H = Hash<K>>
class Set {

    static_assert(std::is_copy_constructible_v<K>, "key type must be copy constructable");

    //--------------------------------------------------------------------------
    // Types

    public:

    using key_type = K;
    using value_type = key_type;
    using hasher = H;
    using reference = value_type &;
    using const_reference = const value_type &;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using size_type = size_t;
    using difference_type = ptrdiff_t;



    //==========================================================================
    // Node
    //--------------------------------------------------------------------------
    // Serves as a node for Slot as a basic linked list.
    //--------------------------------------------------------------------------

    private:

    struct Node {

        size_t hash;
        Node * next;
        K key;

        template <typename K_, typename... ElementArgs>
        Node(size_t hash, Node * next, K_ && key);

    };



    //==========================================================================
    // Iterator
    //--------------------------------------------------------------------------
    // Used to iterate through the set. Comes in mutable and const varieties.
    //--------------------------------------------------------------------------

    private:

    template <bool t_const> class Iterator;

    public:

    using iterator = Iterator<false>;
    using const_iterator = Iterator<true>;



    //--------------------------------------------------------------------------
    // Instance Variables

    private:

    size_t m_size;				        // total number of elements
    size_t m_nSlots;			        // number of slots
    std::unique_ptr<Node *[]> m_slots;  // the slots
    Node * m_nodeStore;                 // a supply of preallocated nodes (an optimization)
    bool m_rehashing;					// the set is currently rehashing



    //==========================================================================
    // Set
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    explicit Set(size_t minNSlots = config::set::defNSlots);
    Set(const Set<K, H> & other);
    Set(Set<K, H> && other);
    template <typename InputIt>
    Set(InputIt first, InputIt last);
    explicit Set(std::initializer_list<K> keys);



    //==========================================================================
    // ~Set
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    ~Set();



    //==========================================================================
    // operator=
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    Set & operator=(const Set<K, H> & other);
    Set & operator=(Set<K, H> && other);
    Set & operator=(std::initializer_list<K> keys);



    //==========================================================================
    // swap
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    void swap(Set<K, H> & set);



    //==========================================================================
    // insert
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    std::pair<iterator, bool> insert(const K & key);
    template <typename InputIt> void insert(InputIt first, InputIt last);
    void insert(std::initializer_list<V> pairs);

    std::pair<iterator, bool> insert_h(size_t hash, const K & key, const E & element);



    //==========================================================================
    // emplace
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    template <typename K_, typename... ElementArgs>
    std::pair<iterator, bool> emplace(K_ && key, ElementArgs &&... elementArgs);

    template <typename K_, typename... ElementArgs>
    std::pair<iterator, bool> emplace_h(size_t hash, K_ && key, ElementArgs &&... elementArgs);



    //==========================================================================
    // at
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    E & at(const K & key) const;

    E & at_h(size_t hash) const;



    //==========================================================================
    // begin
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    iterator begin();
    const_iterator cbegin() const;



    //==========================================================================
    // end
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    iterator end();
    const_iterator cend() const;



    //==========================================================================
    // find
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    iterator find(const K & key);
    const_iterator find(const K & key) const;
    const_iterator cfind(const K & key) const;

    iterator find_h(size_t hash);
    const_iterator find_h(size_t hash) const;
    const_iterator cfind_h(size_t hash) const;



    //==========================================================================
    // find_e
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    iterator find_e(const E & element);
    const_iterator find_e(const E & element) const;
    const_iterator cfind_e(const E & element) const;



    //==========================================================================
    // operator[]
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    E & operator[](const K & key);

    E & access_h(size_t hash, const K & key);



    //==========================================================================
    // erase
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    bool erase(const K & key);
    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);

    bool erase_h(size_t hash);



    //==========================================================================
    // count
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    size_t count(const K & key) const;

    size_t count_h(size_t hash) const;



    //==========================================================================
    // rehash
    //--------------------------------------------------------------------------
    // Resizes the set so that there are at lease minNSlots slots.
    // All elements are re-organized.
    // Relatively expensive method.
    //--------------------------------------------------------------------------

    public:

    void rehash(size_t minNSlots);



    //==========================================================================
    // reserve
    //--------------------------------------------------------------------------
    // Ensures at least nSlots are already allocated.
    //--------------------------------------------------------------------------

    public:

    void reserve(size_t nSlots);



    //==========================================================================
    // clear
    //--------------------------------------------------------------------------
    // clears the set. all slots are cleared. when finished, size = 0
    //--------------------------------------------------------------------------

    public:

    void clear();



    //==========================================================================
    // operator==
    //--------------------------------------------------------------------------
    // Returns whether the elements of the two sets are the same
    //--------------------------------------------------------------------------

    public:

    bool operator==(const Set<K, H> & m) const;



    //==========================================================================
    // operator!=
    //--------------------------------------------------------------------------
    // Returns whether the elements of the two sets are different
    //--------------------------------------------------------------------------

    public:

    bool operator!=(const Set<K, H> & m) const;



    //--------------------------------------------------------------------------
    // Accessors

    public:

    size_t size() const;

    bool empty() const;

    size_t nSlots() const;
    size_t bucket_count() const;

    size_t slotSize(size_t slotI) const;
    size_t bucket_size(size_t slotI) const;

    size_t slot(const K & key) const;
    size_t bucket(const K & key) const;



    //--------------------------------------------------------------------------
    // Private Methods

    private:

    size_t detSlotI(size_t hash) const;

};



//======================================================================================================================
// Iterator ////////////////////////////////////////////////////////////////////////////////////////////////////////////
//======================================================================================================================
// Basic iterator used to iterate forwards over the set.
// iterates forward over the slot, then moves to the next slot.
//------------------------------------------------------------------------------

template <typename K, typename E, typename H>
template <bool t_const> // may be E or const E
class Set<K, H>::Iterator {

    friend Set<K, H>;

    //--------------------------------------------------------------------------
    // Types

    using IE = std::conditional_t<t_const, const E, E>;
    using IV = std::conditional_t<t_const, const typename Set<K, H>::V, typename Set<K, H>::V>;

    using iterator_category = std::forward_iterator_tag;
    using value_type = IV;
    using difference_type = ptrdiff_t;
    using pointer = value_type *;
    using reference = value_type &;

    //--------------------------------------------------------------------------
    // Instance Variables

    private:

    const Set<K, H> * m_set;
    size_t m_slot;
    typename Set<K, H>::Node * m_node;



    //==========================================================================
    // Iterator
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    Iterator(const Set<K, H> & set);
    
    private:

    Iterator(const Set<K, H> & set, size_t slot, typename Set<K, H>::Node * node);

    public:

    template <bool t_const_>
    Iterator(const Iterator<t_const_> & iterator);



    //==========================================================================
    // ~Iterator
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    ~Iterator() = default;



    //==========================================================================
    // operator=
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    template <bool t_const_>
    Iterator<t_const> & operator=(const Iterator<t_const_> & iterator);



    //==========================================================================
    // operator++
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    Iterator<t_const> & operator++();



    //==========================================================================
    // operator++ int
    //--------------------------------------------------------------------------
    // 

    //--------------------------------------------------------------------------

    Iterator<t_const> operator++(int);



    //==========================================================================
    // operator==
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    template <bool t_const_>
    bool operator==(const Iterator<t_const_> & it) const;



    //==========================================================================
    // operator!=
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    template <bool t_const_>
    bool operator!=(const Iterator<t_const_> & it) const;



    //==========================================================================
    // operator*
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    IV & operator*() const;



    //==========================================================================
    // operator->
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    IV * operator->() const;



    //==========================================================================
    // hash
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    size_t hash() const;



    //==========================================================================
    // key
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    const K & key() const;



    //==========================================================================
    // element
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    IE & element() const;

};



//======================================================================================================================
// Functions ///////////////////////////////////////////////////////////////////////////////////////////////////////////
//======================================================================================================================



//==============================================================================
// swap
//------------------------------------------------------------------------------
// 
//------------------------------------------------------------------------------

template <typename K, typename E, typename H>
void swap(Set<K, H> & m1, Set<K, H> & m2);



}



#include "Set.tpp"