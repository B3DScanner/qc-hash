//==============================================================================
// Set.hpp /////////////////////////////////////////////////////////////////////
//==============================================================================
// Austin Quick, 2016 - 2019
//------------------------------------------------------------------------------
// https://github.com/Daskie/QHash
// ...
//------------------------------------------------------------------------------



#pragma once



#include <memory>

#include "Hash.hpp"



namespace qc {



using uchar = unsigned char;



namespace config {

    namespace set {

        constexpr unat defInitCapacity(16);

    }

}



//==============================================================================
// Set
//------------------------------------------------------------------------------
// ...
//------------------------------------------------------------------------------

template <typename V, typename H = Hash<V>, typename E = std::equal_to<V>>
class Set {

    static_assert(std::is_move_constructible_v<V>, "Value type must be move constructable");
    static_assert(std::is_move_assignable_v<V>, "Value type must be move assignable");

    // Types ///////////////////////////////////////////////////////////////////

    private:

    template <bool t_const> class Iterator;

    public:

    using key_type = V;
    using value_type = V;
    using hasher = H;
    using key_equal = E;
    using reference = value_type &;
    using const_reference = const value_type &;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using unatype = unat;
    using difference_type = ptrdiff_t;

    using iterator = Iterator<false>;
    using const_iterator = Iterator<true>;

    // Public Methods //////////////////////////////////////////////////////////

    //==========================================================================
    // Set
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    explicit Set(unat minCapacity = config::set::defInitCapacity);
    Set(const Set<V, H, E> & other);
    Set(Set<V, H, E> && other);
    template <typename It> Set(It first, It last);
    explicit Set(std::initializer_list<V> values);

    private:

    struct PrivateTag {};

    Set(PrivateTag, unat capacity);  

    //==========================================================================
    // ~Set
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    ~Set();

    //==========================================================================
    // operator=
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    Set & operator=(const Set<V, H, E> & other);
    Set & operator=(Set<V, H, E> && other);
    Set & operator=(std::initializer_list<V> values);

    //==========================================================================
    // begin
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    iterator begin();
    const_iterator begin() const;
    const_iterator cbegin() const;

    //==========================================================================
    // end
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    iterator end();
    const_iterator end() const;
    const_iterator cend() const;
    
    //==========================================================================
    // bucket_count
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    unat bucket_count() const;
    
    //==========================================================================
    // max_bucket_count
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    unat max_bucket_count() const;
    
    //==========================================================================
    // bucket_size
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    unat bucket_size(unat i) const;
    
    //==========================================================================
    // bucket_size
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    unat bucket(const V & value) const;
    
    //==========================================================================
    // empty
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    bool empty() const;
    
    //==========================================================================
    // size
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    unat size() const;
    
    //==========================================================================
    // max_size
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    unat max_size() const;

    //==========================================================================
    // clear
    //--------------------------------------------------------------------------
    // All elements are removed and destructed
    // Does not change capacity
    // Invalidates iterators
    //--------------------------------------------------------------------------

    public:

    void clear();

    //==========================================================================
    // insert
    //--------------------------------------------------------------------------
    // ...
    // Invalidates iterators
    //--------------------------------------------------------------------------

    public:

    std::pair<iterator, bool> insert(const V & value);
    std::pair<iterator, bool> insert(V && value);
    template <typename InputIt> void insert(InputIt first, InputIt last);
    void insert(std::initializer_list<V> values);

    //==========================================================================
    // emplace
    //--------------------------------------------------------------------------
    // ...
    // Invalidates iterators
    //--------------------------------------------------------------------------

    public:
    
    template <typename... Args> std::pair<iterator, bool> emplace(Args &&... args);
    std::pair<iterator, bool> emplace(V && v);

    private:

    std::pair<iterator, bool> emplace_h(V && value, unat hash);

    void propagate(V & value, unat i, uchar dist);

    //==========================================================================
    // emplace_hint
    //--------------------------------------------------------------------------
    // Identical to emplace
    // Invalidates iterators
    //--------------------------------------------------------------------------

    public:
    
    template <typename... Args> std::pair<iterator, bool> emplace_hint(const_iterator hint, Args &&... args);

    //==========================================================================
    // erase
    //--------------------------------------------------------------------------
    // ...
    // Invalidates iterators
    //--------------------------------------------------------------------------

    public:

    unat erase(const V & value);
    iterator erase(const_iterator position);

    //==========================================================================
    // swap
    //--------------------------------------------------------------------------
    // ...
    // Invalidates iterators
    //--------------------------------------------------------------------------

    public:

    void swap(Set<V, H, E> & other);

    //==========================================================================
    // count
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    unat count(const V & value) const;

    //==========================================================================
    // find
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    iterator find(const V & value);
    const_iterator find(const V & value) const;
    const_iterator cfind(const V & value) const;

    //==========================================================================
    // contains
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    bool contains(const V & value) const;

    //==========================================================================
    // load_factor
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    float load_factor() const;

    //==========================================================================
    // max_load_factor
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    float max_load_factor() const;

    //==========================================================================
    // rehash
    //--------------------------------------------------------------------------
    // Ensures capacity is at least `minCapacity`
    // If capacity is changed the set is regenerated making this a relatively
    // expensive method
    // Invalidates iterators
    //--------------------------------------------------------------------------

    public:

    void rehash(unat minCapacity);

    //==========================================================================
    // reserve
    //--------------------------------------------------------------------------
    // Ensures capacity is ideal to hold <n> elements
    // Equivalent to `rehash(2 * n)`
    // If capacity is changed the set is regenerated making this a relatively
    // expensive method
    // Invalidates iterators
    //--------------------------------------------------------------------------

    public:

    void reserve(unat n);

    //==========================================================================
    // hash_function
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    hasher hash_function() const;

    //==========================================================================
    // hash_function
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    public:

    key_equal key_eq() const;
    
    // Non-member Functions ////////////////////////////////////////////////////

    //==========================================================================
    // operator==
    //--------------------------------------------------------------------------
    // Returns whether `s1` and `s2` have the same values
    //--------------------------------------------------------------------------

    public:

    template <typename V, typename H, typename E> friend bool operator==(const Set<V, H, E> & s1, const Set<V, H, E> & s2);

    //==========================================================================
    // operator==
    //--------------------------------------------------------------------------
    // Returns whether `s1` and `s2` have different values
    //--------------------------------------------------------------------------

    public:

    template <typename V, typename H, typename E> friend bool operator!=(const Set<V, H, E> & s1, const Set<V, H, E> & s2);

    //==========================================================================
    // swap
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    friend void swap(Set<V, H, E> & s1, Set<V, H, E> & s2);

    // Private Methods /////////////////////////////////////////////////////////

    private:

    struct Chunk {
        union {
            uchar dists[8]; // 0 means no element and distance starts at 1
            uint64_t distsVal;
        };
        V vals[8];
    };

    unat m_size;
    unat m_capacity;
    Chunk * m_chunks;

    void rehash(PrivateTag, unat capacity);

    void expand();

    void allocate();

    void copyChunks(const Chunk * chunks);

    V & valAt(unat i) { return m_chunks[i >> 3].vals[i & 7]; }
    const V & valAt(unat i) const { return m_chunks[i >> 3].vals[i & 7]; }
    uchar & distAt(unat i) { return m_chunks[i >> 3].dists[i & 7]; }
    const uchar & distAt(unat i) const { return m_chunks[i >> 3].dists[i & 7]; }

    struct Ity;

};



//==============================================================================
// Iterator ////////////////////////////////////////////////////////////////////
//==============================================================================
// Forward iterator
//------------------------------------------------------------------------------

template <typename V, typename H, typename E>
template <bool t_const>
class Set<V, H, E>::Iterator {

    friend Set<V, H, E>;

    //--------------------------------------------------------------------------
    // Types

    using iterator_category = std::forward_iterator_tag;
    using value_type = std::conditional_t<t_const, const V, V>;
    using difference_type = ptrdiff_t;
    using pointer = value_type *;
    using reference = value_type &;

    //==========================================================================
    // Iterator
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------
    
    private:

    Iterator(const uchar * distPtr);
    Iterator(uintptr_t distAddr) : Iterator(reinterpret_cast<const uchar *>(distAddr)) {}

    public:

    template <bool t_const_> Iterator(const Iterator<t_const_> & other);

    //==========================================================================
    // ~Iterator
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    ~Iterator() = default;

    //==========================================================================
    // operator=
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    template <bool t_const_> Iterator<t_const> & operator=(const Iterator<t_const_> & other);

    //==========================================================================
    // operator++
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    Iterator<t_const> & operator++();

    //==========================================================================
    // operator++ int
    //--------------------------------------------------------------------------
    // 

    //--------------------------------------------------------------------------

    Iterator<t_const> operator++(int);

    //==========================================================================
    // operator==
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    template <bool t_const_> bool operator==(const Iterator<t_const_> & it) const;

    //==========================================================================
    // operator!=
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    template <bool t_const_> bool operator!=(const Iterator<t_const_> & it) const;

    //==========================================================================
    // operator*
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    const V & operator*() const;

    //==========================================================================
    // operator->
    //--------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------

    const V * operator->() const;

    private:

    union {
        const uchar * ptr;
        uintptr_t addr;
    } m_dist;

};


template <typename V, typename H, typename E>
struct Set<V, H, E>::Ity {
    unat chunkI, subI, i;
    Ity() : chunkI(0), subI(0), i(0) {}
    Ity(unat chunkI, unat subI) : chunkI(chunkI), subI(subI), i((chunkI << 3) | subI) {}
    Ity(unat i) : chunkI(i >> 3), subI(i & 0b111), i(i) {}
    Ity(const Ity & ity) : chunkI(ity.chunkI), subI(ity.subI) {}
    Ity & operator=(const Ity & ity) { chunkI = ity.chunkI; subI = ity.subI; }
    Ity & operator++() {
        ++i;

        // TODO: compare
        if (++subI >= 8) {
            subI = 0;
            ++chunkI;
        }

        //subI = (subI + 1) & 0b111;
        //chunkI += !subI;
    }
};



}



#include "Set.tpp"